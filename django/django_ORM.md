# Django ORM

* mainapp/models.py
```python
from django.db import models

class Book(models.Model):
    book_name = models.CharField(max_length=100)


class Author(models.Model):
    name = models.CharField(max_length=100)
    book = models.ForeignKey(Book, on_delete=models.CASCADE)
```
* создаем файл мигации т.е. создается файл mainapp/migrations/0001_initial.py в котором написана инструкция, какие изменения внести в базу данных чтобы сформировалась нужна структура
```
python manage.py makemigrations
```
* содержимое файла сгенерировалось автоматически, изменять его не нужно
```python
# Generated by Django 4.2.4 on 2023-09-10 16:48

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Book',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('book_name', models.CharField(max_length=100)),
            ],
        ),
        migrations.CreateModel(
            name='Author',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='mainapp.book')),
            ],
        ),
    ]

```
* применяем миграции т.е. создаем структуру в самой БД, в коробке идет БД sqlite3
```
python manage.py migrate
```
* если нам нужно вернуться к миграции к другой миграции мы выполним следующую команду
```
python manage.py migrate mainapp 0005_second_last_migration
```
* если нам нужно отменить все миграции приложения, мы воспользуемся следующей командой
```
python manage.py migrate mainapp zero
```
* если нам нужно полностью очистить всю базу данных, мы можем использовать следующую команду
```
python manage.py flush
```
* натройки базы данных есть в файле config/settings.py
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
### подключаем Postgres
* проверяем если Postgres уже есть
```
pg_config --version
```
* обновляем систему и устанавливаем Postgres
```
sudo apt update && sudo apt install postgresql postgresql-contrib
```
* В ходе установки была создана учетную запись пользователя postgres, которая связана с используемой по умолчанию ролью postgres.
  
* драйвер для подключения postgres
```
pip install psycopg2-binary
```
заходим в коммандрую строку psql
```
sudo -u postgres psql
```
* создаем БД
```
CREATE DATABASE db_name;
```
* изменяем настройки в config/settings.py
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'library',
        'USER': 'postgres',
        'PASSWORD': 'postgres',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```
```
python manage.py migrate
```
* открыть консоль postgres
```
sudo -u postgres psql
```
* список БД
```
\l
```
* создать БД
```
CREATE DATABASE db_name;
```
* переход на нужную БД
```
\c db_name
```
* показать все таблицы БД
```
\d
```
* открыть свойства таблицы БД
```
\d table_name
```
* открыть таблицу
```
SELECT * FROM table_name;
```
* удалить БД
```
DROP DATABASE db_name;
```
* если появляется ошибка ERROR:  database "library" is being accessed by other users
```sql
SELECT pg_terminate_backend (pg_stat_activity.pid)
FROM pg_stat_activity
WHERE pg_stat_activity.datname = 'db_name' AND pid <> pg_backend_pid();

```
* передать данные из view в БД
```python
from mainapp.models import Book

def orm(request):
    data = Book(name='some_data')
    data.save()

    return render(request, 'mainapp/orm.html')
```
* получение данных из БД
```python
from mainapp.models import Book

def get_data_orm(request):
    data = Book.objects.all()
    #действие с данными
    context = {
            data: 'data',
        }

    return render(request, 'mainapp/orm.html', context)
```
* настройка админки
```
python manage.py createsuperuser
```
* в mainapp/admin.py
```python
from django.contrib import admin
from .models import Book


@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    list_display = 'id', 'book_name'
```
```
http://127.0.0.1:8000/admin/
```
* создаем связи Продукт -> Заказ на примере книжного магазина
* в mainapp/models.py
```python
from django.db import models


class Books(models.Model):
    author_name = models.CharField(max_length=100)
    book_name = models.CharField(max_length=100)
    book_price = models.DecimalField(max_digits=10, decimal_places=2, default=0.00)

    class Meta:
        verbose_name = "Book"
        verbose_name_plural = "Books"


class Orders(models.Model):
    description = models.CharField(max_length=100)

    class Meta:
        verbose_name = "Orders"
        verbose_name_plural = "Orders"


class Order(models.Model):
    product = models.ForeignKey(Books, on_delete=models.CASCADE, related_name='position')
    # related_name задан как 'position', то вы сможете получить все заказы,
    # связанные с конкретной книгой, используя это имя. Например:
    # Получение всех заказов для определенной книги

    # book = Books.objects.get(id=1)  # Предположим, что у книги есть id=1
    # orders = book.orders.all()
    order = models.ForeignKey(Orders, on_delete=models.CASCADE, related_name='positions')
    # on_delete=models.CASCADE означает
    # Если объект Books, на который ссылается поле product, будет удален, то все объекты Cart,
    # которые имеют эту Books в качестве значения поля product, также будут удалены.
    # То есть, удаление Books приведет к удалению всех связанных объектов Cart
    quantity = models.IntegerField()

    class Meta:
        verbose_name = "Order"
        verbose_name_plural = "Order"

```
* создаем БД и делаем миграции
* настраиваем админку
* где OrderPositionsInLine - для построчного отображения товаров в заказе
```python
from django.contrib import admin
from .models import Books, Orders, Order


class OrderPositionsInLine(admin.TabularInline):
    model = Order
    extra = 0


@admin.register(Books)
class BooksAdmin(admin.ModelAdmin):
    list_display = ['id', 'author_name', 'book_name', 'book_price']


@admin.register(Orders)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'description']
    inlines = [OrderPositionsInLine]

```
* для отображения названия объекта в админке добавляем в class Books
```python
    def __str__(self):
        return f'{self.book_name, self.author_name}'
```
* Shell_plus для доступа к данным БД
```
pip install django-extensions
```
* Добавим django-extensions в файл config/settings.py
```python
INSTALLED_APPS = [
    # ...
    'django_extensions',
    'mainapp',
]
```
* чтобы shell отрисовывал SQL запросы
```
python manage.py shell_plus --print-sql
```
### отношения Django One-To-One
* в родительской таблице Employee вы добавите OneToOneField, который используется для определения связи между двумя таблицами
```python
class Contact(models.Model):
    phone = models.CharField(max_length=50, unique=True)
    address = models.CharField(max_length=50)

    def __str__(self):
        return self.phone


class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)

    def __str__(self):
        return f'{self.first_name} {self.last_name}'
```
* при этом связать данные между таблицами прийдется вручную, например
```
e = Employee(first_name='John',last_name='Doe')
e.save()
```
```
c = Contact(phone='+79120000000', address='Moscow city, Leninsky avenue, house 11')
c.save()
```
* делаем связку
```
e.contact = c
e.save()
```
* при попытке привязать такойже Contact к еще одному сотрудникоу возникнет ошибка
```
django.db.utils.IntegrityError: duplicate key value violates unique constraint "mainapp_employee_contact_id_key"
```
### отношения Django One-To-Many
* например когда несколько сотрундников работают в одном отделе, но при этом один конкретный сотрудник может работать тольков одном отделе
* данная структура реализуюется через строку
```
department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
```
```python
class Contact(models.Model):
    phone = models.CharField(max_length=50, unique=True)
    address = models.CharField(max_length=50)

    def __str__(self):
        return self.phone


class Department(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.name


class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)

    def __str__(self):
        return f'{self.first_name} {self.last_name}'
```
* запускаем shell_plus
```
python manage.py shell_plus --print-sql
```
* добавляем сотрудника
```
e = Employee(first_name='Jane',last_name='Doe')
e.save()
```
* добавляем отдел
```
d = Department(name='IT',description='Information Technology')
d.save()
```
* присваиваем сотруднику отдел
```
e.department = d
```
### отношения Django Many-to-Many
* например когда скольок угодно сотрудников имеют зарплатные программы и соответственно зарплатные программы могут относиться к скольки угодно сотрудникам
* связь реализуется через строчку
```
compensations = models.ManyToManyField(Compensation)
```
```python
class Compensation(models.Model):
    name = models.CharField(max_length=255)

    def __str__(self):
        return self.name


class Contact(models.Model):
    phone = models.CharField(max_length=50, unique=True)
    address = models.CharField(max_length=50)

    def __str__(self):
        return self.phone


class Department(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.name


class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None)
    compensations = models.ManyToManyField(Compensation)

    def __str__(self):
        return f'{self.first_name} {self.last_name}'
```
* Djnago создает соединительную таблицу hr_employee_compensations. Она имеет два внешних ключа employee_id  и  compensation_id
* внешний employee_id ключ ссылается на id таблицу hr_employee, а compensation_id внешний ключ ссылается id на hr_compensation таблицу.
* запускаем shell_plus
```
python manage.py shell_plus --print-sql
```
* Создадим три зарплатные программы
```
c1 = Compensation(name='Stock')
c1.save()
c2 = Compensation(name='Bonuses') 
c2.save()
c3 = Compensation(name='Profit Sharing')  
c3.save()
```
* выберем любого сотрудника
```
e = Employee.objects.get(id=8)
```
* присвоим ему пару зарплатных программ
```
e.compensations.add(c1)
e.compensations.add(c2) 
e.save()
```
* внутри Django вставил идентификаторы сотрудников и компенсаций в таблицу соединений - hr_employee_compensations
* мы можем найти всех сотрудников по зарплатной программе использую set
```
c1.employee_set.all()
```
* или тоже самое, но подругому
```
Employee.objects.filter(compensations__id=1)
```
* чтобы удалить зарплатную программу у сотрудника используем remove()
```
e.compensations.remove(c2)
```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```

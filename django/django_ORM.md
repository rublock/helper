# Django ORM

* mainapp/models.py
```python
from django.db import models

class Book(models.Model):
    book_name = models.CharField(max_length=100)


class Author(models.Model):
    name = models.CharField(max_length=100)
    book = models.ForeignKey(Book, on_delete=models.CASCADE)
```
* создаем файл мигации т.е. создается файл mainapp/migrations/0001_initial.py в котором написана инструкция, какие изменения внести в базу данных чтобы сформировалась нужна структура
```
python manage.py makemigrations
```
* содержимое файла сгенерировалось автоматически, изменять его не нужно
```python
# Generated by Django 4.2.4 on 2023-09-10 16:48

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Book',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('book_name', models.CharField(max_length=100)),
            ],
        ),
        migrations.CreateModel(
            name='Author',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('book', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='mainapp.book')),
            ],
        ),
    ]

```
* применяем миграции т.е. создаем структуру в самой БД, в коробке идет БД sqlite3
```
python manage.py migrate
```
* если нам нужно вернуться к миграции к другой миграции мы выполним следующую команду
```
python manage.py migrate mainapp 0005_second_last_migration
```
* если нам нужно отменить все миграции приложения, мы воспользуемся следующей командой
```
python manage.py migrate mainapp zero
```
* если нам нужно полностью очистить всю базу данных, мы можем использовать следующую команду
```
python manage.py flush
```
* натройки базы данных есть в файле config/settings.py
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```
* чтобы подключить postgres
```
sudo apt update && sudo apt install postgresql
```
* драйвер для подключения postgres
```
pip install psycopg2-binary
```
```
createdb -U postgres library
```
* изменяем настройки в config/settings.py
```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'library',
        'USER': 'postgres',
        'PASSWORD': 'postgres',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```
```
python manage.py migrate
```
* открыть консоль postgres
```
sudo -u postgres psql
```
* список БД
```
\l
```
* создать БД
```
CREATE DATABASE db_name;
```
* переход на нужную БД
```
\c db_name
```
* показать все таблицы БД
```
\d
```
* открыть свойства таблицы БД
```
\d table_name
```
* открыть таблицу
```
SELECT * FROM table_name;
```
* удалить БД
```
DROP DATABASE db_name;
```
* если появляется ошибка ERROR:  database "library" is being accessed by other users
```sql
SELECT pg_terminate_backend (pg_stat_activity.pid)
FROM pg_stat_activity
WHERE pg_stat_activity.datname = 'db_name' AND pid <> pg_backend_pid();

```
* передать данные из view в БД
```python
from mainapp.models import Book

def orm(request):
    data = Book(name='some_data')
    data.save()

    return render(request, 'mainapp/orm.html')
```
* получение данных из БД
```python
from mainapp.models import Book

def get_data_orm(request):
    data = Book.objects.all()
    #действие с данными
    context = {
            data: 'data',
        }

    return render(request, 'mainapp/orm.html', context)
```
* настройка админки
```
python manage.py createsuperuser
```
* в mainapp/admin.py
```python
from django.contrib import admin
from .models import Book


@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    list_display = 'id', 'book_name'
```
```
http://127.0.0.1:8000/admin/
```
* создаем связи Продукт -> Заказ на примере книжного магазина
* в mainapp/models.py
```python
from django.db import models


class Books(models.Model):
    author_name = models.CharField(max_length=100)
    book_name = models.CharField(max_length=100)
    book_price = models.DecimalField(max_digits=10, decimal_places=2, default=0.00)

    class Meta:
        verbose_name = "Book"
        verbose_name_plural = "Books"


class Orders(models.Model):
    description = models.CharField(max_length=100)

    class Meta:
        verbose_name = "Orders"
        verbose_name_plural = "Orders"


class Order(models.Model):
    product = models.ForeignKey(Books, on_delete=models.CASCADE, related_name='position')
    # related_name задан как 'position', то вы сможете получить все заказы,
    # связанные с конкретной книгой, используя это имя. Например:
    # Получение всех заказов для определенной книги

    # book = Books.objects.get(id=1)  # Предположим, что у книги есть id=1
    # orders = book.orders.all()
    order = models.ForeignKey(Orders, on_delete=models.CASCADE, related_name='positions')
    # on_delete=models.CASCADE означает
    # Если объект Books, на который ссылается поле product, будет удален, то все объекты Cart,
    # которые имеют эту Books в качестве значения поля product, также будут удалены.
    # То есть, удаление Books приведет к удалению всех связанных объектов Cart
    quantity = models.IntegerField()

    class Meta:
        verbose_name = "Order"
        verbose_name_plural = "Order"

```
* создаем БД и делаем миграции
* настраиваем админку
* где OrderPositionsInLine - для построчного отображения товаров в заказе
```python
from django.contrib import admin
from .models import Books, Orders, Order


class OrderPositionsInLine(admin.TabularInline):
    model = Order
    extra = 0


@admin.register(Books)
class BooksAdmin(admin.ModelAdmin):
    list_display = ['id', 'author_name', 'book_name', 'book_price']


@admin.register(Orders)
class OrderAdmin(admin.ModelAdmin):
    list_display = ['id', 'description']
    inlines = [OrderPositionsInLine]

```
* для отображения названия объекта в админке добавляем в class Books
```python
    def __str__(self):
        return f'{self.book_name, self.author_name}'
```
* Shell_plus для доступа к данным БД
```
pip install django-extensions
```
* Добавим django-extensions в файл config/settings.py
```python
INSTALLED_APPS = [
    # ...
    'django_extensions',
    'mainapp',
]
```
* чтобы shell отрисовывал SQL запросы
```
python manage.py shell_plus --print-sql
```
### отношения Django One-To-One
* в родительской таблице Employee вы добавите OneToOneField, который используется для определения связи между двумя таблицами
```python
class Contact(models.Model):
    phone = models.CharField(max_length=50, unique=True)
    address = models.CharField(max_length=50)

    def __str__(self):
        return self.phone


class Employee(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    contact = models.OneToOneField(Contact, on_delete=models.CASCADE, null=True)

    def __str__(self):
        return f'{self.first_name} {self.last_name}'
```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
* 
```

```
